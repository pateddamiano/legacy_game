<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>First Off - Play Now!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        
        #gameWrapper {
            position: relative;
            max-width: 100vw;
            max-height: 100vh;
        }
        
        canvas {
            border: 3px solid #e74c3c;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(231, 76, 60, 0.5);
            background: #2c3e50;
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .mobile-notice {
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #f1c40f;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        .controls-hint {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            max-width: 200px;
        }
        
        .play-button {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
            transition: all 0.3s ease;
            z-index: 2000;
            display: none;
        }
        
        .play-button:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.6);
        }
        
        .play-button:active {
            transform: translate(-50%, -50%) scale(0.95);
        }
        
        @media (max-width: 768px) {
            .mobile-notice {
                display: block;
            }
            
            .controls-hint {
                display: none;
            }
            
            body {
                padding: 5px;
            }
        }
        
        .fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #e74c3c;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            z-index: 1000;
        }
        
        .fullscreen-btn:hover {
            background: rgba(231, 76, 60, 0.8);
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
        <!-- Game canvas will be inserted here -->
    </div>
    
    <div class="controls-hint">
        <strong>Controls:</strong><br>
        Arrow Keys: Move & Jump<br>
        Space: Switch Character<br>
        Enter: Super Move<br>
        P: Pause
    </div>
    
    <div class="mobile-notice">
        ðŸ“± Touch the screen to control your character!
    </div>
    
    <button class="fullscreen-btn" onclick="toggleFullscreen()">ðŸ“º Fullscreen</button>
    
    <button class="play-button" id="playButton" onclick="startGame()">ðŸŽ® PLAY NOW</button>
    
    <script>
/**
 * FIRST OFF - Brooklyn Street Mini Game (Complete Standalone Version)
 * Fully functional JavaScript game for web browsers and mobile devices
 */

class FirstOffGame {
    constructor() {
        this.canvas = null;
        this.ctx = null;
        this.gameState = 'loading';
        this.lastFrameTime = 0;
        this.frameCount = 0;
        
        // Game configuration
        this.config = {
            canvas: { width: 800, height: 600 },
            player: {
                width: 40, height: 60, speed: 5, jumpPower: -14,
                gravity: 0.6, maxHealth: 100
            },
            game: {
                duration: 150, // 2.5 minutes
                baseSpeed: 2.5, maxSpeed: 6,
                bossWaveStart: 30,
                spawnRate: 0.02,
                microphoneSpawnRate: 0.012
            }
        };
        
        // Game state
        this.score = 0;
        this.gameTime = this.config.game.duration;
        this.gameSpeed = 1;
        this.currentCharacter = 'tireek';
        this.highScore = this.loadHighScore();
        this.availableCharacters = ['tireek', 'tryston'];
        
        // Characters
        this.characters = {
            tireek: {
                name: 'Tireek', color: '#3498db', secondaryColor: '#2980b9',
                superMove: 'punch', superMeter: 0, maxSuperMeter: 100,
                maxHealth: 100, currentHealth: 100, isAlive: true
            },
            tryston: {
                name: 'Tryston', color: '#e67e22', secondaryColor: '#d35400',
                superMove: 'yell', superMeter: 0, maxSuperMeter: 100,
                maxHealth: 100, currentHealth: 100, isAlive: true
            }
        };
        
        // Player
        this.player = {
            x: 100, y: 400, width: 40, height: 60,
            velocityY: 0, onGround: false,
            isInvulnerable: false, invulnerabilityTime: 0
        };
        
        // Game objects
        this.obstacles = [];
        this.microphones = [];
        this.particles = [];
        this.keys = {};
        this.touchControls = {};
        
        // Brooklyn atmosphere
        this.atmosphere = { buildings: [], graffiti: [], streetLights: [] };
        
        this.init();
    }
    
    init() {
        this.setupCanvas();
        this.setupControls();
        this.generateBrooklynAtmosphere();
        this.startGameLoop();
        this.showLoadingScreen();
    }
    
    setupCanvas() {
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.config.canvas.width;
        this.canvas.height = this.config.canvas.height;
        this.canvas.id = 'gameCanvas';
        
        this.ctx = this.canvas.getContext('2d');
        this.ctx.imageSmoothingEnabled = true;
        
        document.getElementById('gameWrapper').appendChild(this.canvas);
        
        // Auto-resize for mobile
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
    }
    
    resizeCanvas() {
        const wrapper = document.getElementById('gameWrapper');
        const maxWidth = window.innerWidth - 20;
        const maxHeight = window.innerHeight - 20;
        
        const scaleX = maxWidth / this.config.canvas.width;
        const scaleY = maxHeight / this.config.canvas.height;
        const scale = Math.min(scaleX, scaleY, 1);
        
        this.canvas.style.width = (this.config.canvas.width * scale) + 'px';
        this.canvas.style.height = (this.config.canvas.height * scale) + 'px';
    }
    
    setupControls() {
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));
        this.setupTouchControls();
        this.canvas.addEventListener('contextmenu', e => e.preventDefault());
    }
    
    setupTouchControls() {
        const touchHandler = (e) => {
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const touches = e.touches || [e];
            
            this.touchControls = { left: false, right: false, jump: false, switch: false, super: false };
            
            for (let touch of touches) {
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;
                
                if (x < 200 && y > this.canvas.height - 150) {
                    if (x < 100) this.touchControls.left = true;
                    else this.touchControls.right = true;
                } else if (x > this.canvas.width - 200 && y > this.canvas.height - 150) {
                    if (x > this.canvas.width - 100) this.touchControls.super = true;
                    else this.touchControls.switch = true;
                } else if (y > this.canvas.height - 100) {
                    this.touchControls.jump = true;
                }
            }
        };
        
        this.canvas.addEventListener('touchstart', touchHandler);
        this.canvas.addEventListener('touchmove', touchHandler);
        this.canvas.addEventListener('touchend', () => { this.touchControls = {}; });
        
        // Click/tap to start
        this.canvas.addEventListener('click', () => {
            if (this.gameState === 'menu') this.startGame();
        });
    }
    
    handleKeyDown(e) {
        const key = e.code || e.key;
        switch(key) {
            case 'ArrowLeft': case 'KeyA': this.keys.left = true; break;
            case 'ArrowRight': case 'KeyD': this.keys.right = true; break;
            case 'ArrowUp': case 'KeyW': case 'Space':
                if (key === 'Space' && this.gameState === 'playing') {
                    this.switchCharacter();
                } else {
                    this.keys.jump = true;
                }
                e.preventDefault();
                break;
            case 'Enter': case 'KeyX': this.useSuperMove(); break;
            case 'KeyP':
                if (this.gameState === 'playing') this.gameState = 'paused';
                else if (this.gameState === 'paused') this.gameState = 'playing';
                break;
            case 'KeyR':
                if (this.gameState === 'gameOver' || this.gameState === 'victory') this.resetGame();
                break;
        }
    }
    
    handleKeyUp(e) {
        const key = e.code || e.key;
        switch(key) {
            case 'ArrowLeft': case 'KeyA': this.keys.left = false; break;
            case 'ArrowRight': case 'KeyD': this.keys.right = false; break;
            case 'ArrowUp': case 'KeyW': this.keys.jump = false; break;
        }
    }
    
    generateBrooklynAtmosphere() {
        for (let i = 0; i < 15; i++) {
            this.atmosphere.buildings.push({
                x: i * 60 - 100, width: 50 + Math.random() * 30,
                height: 100 + Math.random() * 150,
                color: `hsl(${200 + Math.random() * 60}, 20%, ${20 + Math.random() * 20}%)`
            });
        }
        
        for (let i = 0; i < 8; i++) {
            this.atmosphere.streetLights.push({
                x: i * 120 + 50, y: this.canvas.height - 120,
                flickering: Math.random() > 0.8
            });
        }
        
        const graffiti = ['++', 'BK', 'NYC', 'FIRST OFF', 'TIREEK', 'TRYSTON'];
        for (let i = 0; i < 6; i++) {
            this.atmosphere.graffiti.push({
                x: Math.random() * this.canvas.width,
                y: this.canvas.height - 200 - Math.random() * 100,
                text: graffiti[Math.floor(Math.random() * graffiti.length)],
                color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                size: 12 + Math.random() * 8
            });
        }
    }
    
    showLoadingScreen() {
        setTimeout(() => { this.gameState = 'menu'; }, 2000);
    }
    
    switchCharacter() {
        if (this.gameState !== 'playing') return;
        
        const currentIndex = this.availableCharacters.indexOf(this.currentCharacter);
        let nextIndex = (currentIndex + 1) % this.availableCharacters.length;
        let attempts = 0;
        
        while (!this.characters[this.availableCharacters[nextIndex]].isAlive && attempts < 2) {
            nextIndex = (nextIndex + 1) % this.availableCharacters.length;
            attempts++;
        }
        
        if (this.characters[this.availableCharacters[nextIndex]].isAlive) {
            this.currentCharacter = this.availableCharacters[nextIndex];
            this.createParticleEffect(
                this.player.x + this.player.width / 2,
                this.player.y + this.player.height / 2,
                this.characters[this.currentCharacter].color, 15, 'switch'
            );
        }
    }
    
    useSuperMove() {
        if (this.gameState !== 'playing') return;
        
        const character = this.characters[this.currentCharacter];
        if (character.superMeter < character.maxSuperMeter) return;
        
        character.superMeter = 0;
        
        if (character.superMove === 'punch') {
            this.tireekPunch();
        } else {
            this.trystonYell();
        }
    }
    
    tireekPunch() {
        let enemiesKilled = 0;
        
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const obstacle = this.obstacles[i];
            if (obstacle.x >= -obstacle.width && obstacle.x <= this.canvas.width + obstacle.width) {
                this.obstacles.splice(i, 1);
                this.score += 15;
                enemiesKilled++;
                this.createParticleEffect(obstacle.x, obstacle.y, '#e74c3c', 12, 'explosion');
            }
        }
        
        this.screenShake = 10;
        this.flashEffect = { intensity: 0.6, color: '#3498db', duration: 20 };
    }
    
    trystonYell() {
        let enemiesKilled = 0;
        
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const obstacle = this.obstacles[i];
            if (obstacle.x >= -obstacle.width && obstacle.x <= this.canvas.width + obstacle.width) {
                this.obstacles.splice(i, 1);
                this.score += 15;
                enemiesKilled++;
                this.createParticleEffect(obstacle.x, obstacle.y, '#f39c12', 10, 'explosion');
            }
        }
        
        this.screenShake = 12;
        this.flashEffect = { intensity: 0.6, color: '#e67e22', duration: 20 };
    }
    
    spawnObstacle() {
        const types = ['vinyl', 'gangster', 'homeless'];
        const difficultyMultiplier = Math.min(this.gameSpeed, 2.5);
        
        let weights;
        if (this.gameTime < 30) {
            weights = [0.2, 0.5, 0.3];
        } else if (this.gameSpeed > 2) {
            weights = [0.3, 0.5, 0.2];
        } else {
            weights = [0.4, 0.3, 0.3];
        }
        
        let type = this.weightedChoice(types, weights);
        
        const obstacle = {
            type: type, x: this.canvas.width + 50, y: this.canvas.height - 120,
            width: 35, height: 50,
            speed: this.config.game.baseSpeed * this.gameSpeed + Math.random() * (1.5 * difficultyMultiplier),
            health: 1, rotation: 0
        };
        
        switch(type) {
            case 'vinyl':
                obstacle.width = 30; obstacle.height = 30; obstacle.y = this.canvas.height - 90;
                obstacle.rotationSpeed = (0.12 + Math.random() * 0.08) * difficultyMultiplier;
                obstacle.color = '#2c3e50';
                break;
            case 'gangster':
                obstacle.speed *= 1.2 + (difficultyMultiplier - 1) * 0.3;
                obstacle.color = '#8e44ad';
                if (difficultyMultiplier > 1.5) {
                    obstacle.pattern = 'zigzag';
                    obstacle.amplitude = 15;
                    obstacle.frequency = 0.08;
                }
                break;
            case 'homeless':
                obstacle.speed *= 0.8 + (difficultyMultiplier - 1) * 0.2;
                obstacle.width = 45;
                obstacle.color = '#95a5a6';
                break;
        }
        
        this.obstacles.push(obstacle);
    }
    
    spawnMicrophone() {
        if (this.gameState === 'paused') return;
        
        this.microphones.push({
            x: this.canvas.width + 30,
            y: this.canvas.height - 180 - Math.random() * 80,
            width: 15, height: 25,
            speed: this.config.game.baseSpeed * this.gameSpeed * 0.8,
            bobOffset: Math.random() * Math.PI * 2,
            collected: false, glow: 0
        });
    }
    
    weightedChoice(items, weights) {
        const total = weights.reduce((sum, weight) => sum + weight, 0);
        let random = Math.random() * total;
        
        for (let i = 0; i < items.length; i++) {
            random -= weights[i];
            if (random <= 0) return items[i];
        }
        
        return items[items.length - 1];
    }
    
    updatePlayer() {
        if (this.gameState !== 'playing') return;
        
        const isLeft = this.keys.left || this.touchControls.left;
        const isRight = this.keys.right || this.touchControls.right;
        const isJump = this.keys.jump || this.touchControls.jump;
        
        if (isLeft && this.player.x > 0) {
            this.player.x -= this.config.player.speed;
        }
        if (isRight && this.player.x < this.canvas.width - this.player.width) {
            this.player.x += this.config.player.speed;
        }
        
        if (isJump && this.player.onGround) {
            this.player.velocityY = this.config.player.jumpPower;
            this.player.onGround = false;
        }
        
        this.player.y += this.player.velocityY;
        this.player.velocityY += this.config.player.gravity;
        
        const groundY = this.canvas.height - this.player.height - 50;
        if (this.player.y >= groundY) {
            this.player.y = groundY;
            this.player.velocityY = 0;
            this.player.onGround = true;
        }
        
        if (this.player.isInvulnerable) {
            this.player.invulnerabilityTime--;
            if (this.player.invulnerabilityTime <= 0) {
                this.player.isInvulnerable = false;
            }
        }
    }
    
    updateObstacles() {
        if (this.gameState === 'paused') return;
        
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const obstacle = this.obstacles[i];
            
            if (obstacle.pattern === 'zigzag') {
                obstacle.y += Math.sin(this.frameCount * obstacle.frequency) * obstacle.amplitude * 0.1;
            }
            
            obstacle.x -= obstacle.speed;
            
            if (obstacle.type === 'vinyl') {
                obstacle.rotation += obstacle.rotationSpeed;
            }
            
            if (obstacle.x + obstacle.width < 0) {
                this.obstacles.splice(i, 1);
                this.score += 5;
                continue;
            }
            
            if (!this.player.isInvulnerable && this.checkCollision(this.player, obstacle)) {
                this.playerHit(obstacle);
                this.obstacles.splice(i, 1);
            }
        }
    }
    
    updateMicrophones() {
        if (this.gameState === 'paused') return;
        
        for (let i = this.microphones.length - 1; i >= 0; i--) {
            const mic = this.microphones[i];
            
            mic.x -= mic.speed;
            mic.bobOffset += 0.1;
            mic.glow = Math.sin(this.frameCount * 0.1) * 0.5 + 0.5;
            
            if (mic.x + mic.width < 0) {
                this.microphones.splice(i, 1);
                continue;
            }
            
            if (this.checkCollision(this.player, mic)) {
                this.microphones.splice(i, 1);
                this.collectMicrophone();
            }
        }
    }
    
    updateParticles() {
        if (this.gameState === 'paused') return;
        
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            
            particle.x += particle.vx;
            particle.y += particle.vy;
            
            if (particle.gravity) {
                particle.vy += particle.gravity;
            }
            
            particle.life--;
            particle.vx *= 0.98;
            particle.vy *= 0.98;
            
            if (particle.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
    }
    
    checkCollision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }
    
    playerHit(obstacle) {
        const character = this.characters[this.currentCharacter];
        const damage = 25;
        
        character.currentHealth -= damage;
        this.player.isInvulnerable = true;
        this.player.invulnerabilityTime = 90;
        
        this.createParticleEffect(
            this.player.x + this.player.width / 2,
            this.player.y + this.player.height / 2,
            '#e74c3c', 10, 'hit'
        );
        
        this.screenShake = 6;
        
        if (character.currentHealth <= 0) {
            character.isAlive = false;
            
            const aliveCharacters = Object.keys(this.characters).filter(
                name => this.characters[name].isAlive
            );
            
            if (aliveCharacters.length === 0) {
                this.gameState = 'gameOver';
                this.saveHighScore();
            } else {
                const nextCharacter = aliveCharacters[0];
                this.currentCharacter = nextCharacter;
                
                this.createParticleEffect(
                    this.player.x + this.player.width / 2,
                    this.player.y + this.player.height / 2,
                    this.characters[this.currentCharacter].color, 20, 'switch'
                );
                
                this.flashEffect = { intensity: 0.7, color: this.characters[this.currentCharacter].color, duration: 30 };
            }
        }
    }
    
    collectMicrophone() {
        const character = this.characters[this.currentCharacter];
        character.superMeter = Math.min(character.maxSuperMeter, character.superMeter + 25);
        this.score += 25;
        
        this.createParticleEffect(
            this.player.x + this.player.width / 2,
            this.player.y + this.player.height / 2,
            '#f1c40f', 15, 'collect'
        );
    }
    
    createParticleEffect(x, y, color, count, type) {
        for (let i = 0; i < count; i++) {
            let particle = {
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                color: color, life: 30 + Math.random() * 20,
                maxLife: 50, size: 2 + Math.random() * 2, type: type
            };
            
            if (type === 'switch') {
                particle.vx *= 1.5;
                particle.vy = -Math.abs(particle.vy) * 1.5;
            } else if (type === 'collect') {
                particle.vy = -Math.abs(particle.vy) * 2;
                particle.gravity = 0.1;
            } else if (type === 'explosion') {
                particle.vx *= 2;
                particle.vy *= 2;
                particle.size *= 1.5;
            }
            
            this.particles.push(particle);
        }
    }
    
    updateGameLogic() {
        if (this.gameState !== 'playing') return;
        
        this.frameCount++;
        
        this.gameTime -= 1/60;
        if (this.gameTime <= 0) {
            this.gameState = 'victory';
            this.saveHighScore();
            return;
        }
        
        const timeProgress = 1 - (this.gameTime / this.config.game.duration);
        this.gameSpeed = 1 + timeProgress * 2;
        
        const difficultyMultiplier = Math.min(this.gameSpeed, 2.5);
        
        const inBossWave = this.gameTime <= this.config.game.bossWaveStart;
        const baseSpawnRate = this.config.game.spawnRate * difficultyMultiplier;
        const spawnRate = inBossWave ? baseSpawnRate * 2.2 : baseSpawnRate;
        
        const maxObstacles = Math.floor(8 + (difficultyMultiplier - 1) * 4);
        const minSpacing = Math.max(80, 120 - (difficultyMultiplier - 1) * 20);
        
        if (Math.random() < spawnRate && this.obstacles.length < maxObstacles) {
            const lastObstacle = this.obstacles[this.obstacles.length - 1];
            if (!lastObstacle || this.canvas.width - lastObstacle.x > minSpacing) {
                this.spawnObstacle();
            }
        }
        
        const micSpawnRate = this.config.game.microphoneSpawnRate * (1 + (difficultyMultiplier - 1) * 0.5);
        if (Math.random() < micSpawnRate) {
            this.spawnMicrophone();
        }
        
        if (this.screenShake > 0) {
            this.screenShake--;
        }
        
        if (this.flashEffect && this.flashEffect.duration > 0) {
            this.flashEffect.duration--;
        }
    }
    
    render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        let shakeX = 0, shakeY = 0;
        if (this.screenShake > 0) {
            shakeX = (Math.random() - 0.5) * this.screenShake;
            shakeY = (Math.random() - 0.5) * this.screenShake;
        }
        
        this.ctx.save();
        this.ctx.translate(shakeX, shakeY);
        
        if (this.gameState === 'loading') {
            this.renderLoadingScreen();
        } else if (this.gameState === 'menu') {
            this.renderMainMenu();
        } else if (this.gameState === 'playing' || this.gameState === 'paused') {
            this.renderGame();
            if (this.gameState === 'paused') {
                this.renderPauseOverlay();
            }
        } else if (this.gameState === 'gameOver') {
            this.renderGame();
            this.renderGameOverScreen();
        } else if (this.gameState === 'victory') {
            this.renderGame();
            this.renderVictoryScreen();
        }
        
        this.ctx.restore();
        
        if (this.flashEffect && this.flashEffect.duration > 0) {
            this.ctx.save();
            this.ctx.globalAlpha = this.flashEffect.intensity * (this.flashEffect.duration / 20);
            this.ctx.fillStyle = this.flashEffect.color;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.restore();
        }
    }
    
    renderLoadingScreen() {
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        gradient.addColorStop(0, '#2c3e50');
        gradient.addColorStop(1, '#34495e');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.fillStyle = '#e74c3c';
        this.ctx.font = 'bold 48px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('FIRST OFF', this.canvas.width / 2, this.canvas.height / 2 - 50);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.font = '24px Arial';
        this.ctx.fillText('Brooklyn Street Challenge', this.canvas.width / 2, this.canvas.height / 2 + 10);
        this.ctx.fillText('2:30 Medium Difficulty', this.canvas.width / 2, this.canvas.height / 2 + 40);
        
        const barWidth = 300;
        const barHeight = 20;
        const barX = (this.canvas.width - barWidth) / 2;
        const barY = this.canvas.height / 2 + 80;
        
        this.ctx.strokeStyle = '#ecf0f1';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        const progress = Math.min(1, this.frameCount / 120);
        this.ctx.fillStyle = '#e74c3c';
        this.ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * progress, barHeight - 4);
        
        this.ctx.textAlign = 'left';
    }
    
    renderMainMenu() {
        this.renderBrooklynBackground();
        
        this.ctx.fillStyle = 'rgba(44, 62, 80, 0.8)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.fillStyle = '#e74c3c';
        this.ctx.font = 'bold 64px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('FIRST OFF', this.canvas.width / 2, 120);
        
        this.ctx.fillStyle = '#f39c12';
        this.ctx.font = '20px Arial';
        this.ctx.fillText('2:30 Brooklyn Challenge', this.canvas.width / 2, 160);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.font = '24px Arial';
        this.ctx.fillText('Choose Your Character', this.canvas.width / 2, 220);
        
        const tireekX = this.canvas.width / 2 - 120;
        const trystonX = this.canvas.width / 2 + 120;
        const charY = 300;
        
        this.ctx.fillStyle = this.characters.tireek.isAlive ? this.characters.tireek.color : '#7f8c8d';
        this.ctx.fillRect(tireekX - 30, charY - 40, 60, 80);
        this.ctx.fillStyle = this.characters.tireek.isAlive ? '#ecf0f1' : '#95a5a6';
        this.ctx.font = '18px Arial';
        this.ctx.fillText('TIREEK', tireekX, charY + 60);
        this.ctx.font = '14px Arial';
        this.ctx.fillText('Screen Clear Punch', tireekX, charY + 80);
        
        this.ctx.fillStyle = this.characters.tryston.isAlive ? this.characters.tryston.color : '#7f8c8d';
        this.ctx.fillRect(trystonX - 30, charY - 40, 60, 80);
        this.ctx.fillStyle = this.characters.tryston.isAlive ? '#ecf0f1' : '#95a5a6';
        this.ctx.font = '18px Arial';
        this.ctx.fillText('TRYSTON', trystonX, charY + 60);
        this.ctx.font = '14px Arial';
        this.ctx.fillText('Screen Clear Yell', trystonX, charY + 80);
        
        const selectedX = this.currentCharacter === 'tireek' ? tireekX : trystonX;
        this.ctx.strokeStyle = '#f1c40f';
        this.ctx.lineWidth = 3;
        this.ctx.strokeRect(selectedX - 35, charY - 45, 70, 90);
        
        this.ctx.fillStyle = '#95a5a6';
        this.ctx.font = '16px Arial';
        this.ctx.fillText('Both super moves clear ALL enemies on screen!', this.canvas.width / 2, 430);
        this.ctx.fillText('Collect microphones to charge super meters!', this.canvas.width / 2, 450);
        
        this.ctx.fillStyle = '#27ae60';
        this.ctx.font = '20px Arial';
        this.ctx.fillText('CLICK TO START!', this.canvas.width / 2, 490);
        
        this.ctx.fillStyle = '#f1c40f';
        this.ctx.font = 'bold 20px Arial';
        this.ctx.fillText(`High Score: ${this.highScore}`, this.canvas.width / 2, 530);
        
        this.ctx.textAlign = 'left';
        
        if (this.keys.left || this.keys.right) {
            this.switchCharacter();
            this.keys.left = this.keys.right = false;
        }
        
        if (this.keys.jump || this.touchControls.jump) {
            this.startGame();
        }
    }
    
    renderGame() {
        this.renderBrooklynBackground();
        
        this.ctx.fillStyle = '#34495e';
        this.ctx.fillRect(0, this.canvas.height - 50, this.canvas.width, 50);
        
        this.ctx.strokeStyle = '#f1c40f';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([10, 10]);
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.canvas.height - 25);
        this.ctx.lineTo(this.canvas.width, this.canvas.height - 25);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        this.renderObstacles();
        this.renderMicrophones();
        this.renderPlayer();
        this.renderParticles();
        this.renderUI();
        
        if (this.gameTime <= this.config.game.bossWaveStart && Math.floor(this.frameCount / 40) % 2) {
            this.ctx.fillStyle = '#e74c3c';
            this.ctx.font = 'bold 24px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('FINAL WAVE!', this.canvas.width / 2, 50);
            this.ctx.textAlign = 'left';
        }
        
        // Mobile touch controls
        if (window.innerWidth <= 768) {
            this.renderTouchControls();
        }
    }
    
    renderBrooklynBackground() {
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height * 0.6);
        gradient.addColorStop(0, '#34495e');
        gradient.addColorStop(0.5, '#2c3e50');
        gradient.addColorStop(1, '#1a252f');
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height * 0.6);
        
        this.atmosphere.buildings.forEach(building => {
            this.ctx.fillStyle = building.color;
            this.ctx.fillRect(
                building.x - this.frameCount * 0.15, 
                this.canvas.height - building.height - 50,
                building.width, building.height
            );
            
            this.ctx.fillStyle = Math.random() > 0.7 ? '#f1c40f' : '#2c3e50';
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < Math.floor(building.height / 20); j++) {
                    this.ctx.fillRect(
                        building.x - this.frameCount * 0.15 + 5 + i * 15,
                        this.canvas.height - building.height - 50 + 10 + j * 20,
                        8, 12
                    );
                }
            }
        });
        
        this.atmosphere.streetLights.forEach(light => {
            this.ctx.fillStyle = '#7f8c8d';
            this.ctx.fillRect(light.x - this.frameCount * 0.08, light.y, 5, 100);
            
            if (!light.flickering || Math.floor(this.frameCount / 12) % 2) {
                this.ctx.fillStyle = 'rgba(241, 196, 15, 0.6)';
                this.ctx.beginPath();
                this.ctx.arc(light.x - this.frameCount * 0.08 + 2.5, light.y, 12, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
        
        this.atmosphere.graffiti.forEach(graf => {
            this.ctx.fillStyle = graf.color;
            this.ctx.font = `bold ${graf.size}px Arial`;
            this.ctx.fillText(graf.text, graf.x - this.frameCount * 0.03, graf.y);
        });
    }
    
    renderPlayer() {
        const character = this.characters[this.currentCharacter];
        
        if (this.player.isInvulnerable && Math.floor(this.frameCount / 4) % 2) {
            this.ctx.globalAlpha = 0.6;
        }
        
        this.ctx.fillStyle = character.color;
        this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
        
        this.ctx.fillStyle = character.secondaryColor;
        this.ctx.fillRect(this.player.x + 5, this.player.y + 5, this.player.width - 10, 20);
        
        this.ctx.fillStyle = '#f4d03f';
        this.ctx.fillRect(this.player.x + 10, this.player.y + 10, 20, 20);
        
        this.ctx.fillStyle = '#2c3e50';
        this.ctx.fillRect(this.player.x + 13, this.player.y + 15, 3, 3);
        this.ctx.fillRect(this.player.x + 19, this.player.y + 15, 3, 3);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(character.name, this.player.x + this.player.width / 2, this.player.y - 5);
        this.ctx.textAlign = 'left';
        
        this.ctx.globalAlpha = 1;
    }
    
    renderObstacles() {
        this.obstacles.forEach(obstacle => {
            this.ctx.save();
            
            if (obstacle.type === 'vinyl') {
                const centerX = obstacle.x + obstacle.width / 2;
                const centerY = obstacle.y + obstacle.height / 2;
                
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(obstacle.rotation);
                
                this.ctx.fillStyle = obstacle.color;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, obstacle.width / 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 4, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#34495e';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 6 + i * 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            } else {
                this.ctx.fillStyle = obstacle.color;
                this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                this.ctx.fillStyle = '#f4d03f';
                this.ctx.fillRect(obstacle.x + 5, obstacle.y + 5, obstacle.width - 10, 15);
                
                this.ctx.fillStyle = '#ecf0f1';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                const label = obstacle.type === 'gangster' ? 'G' : 'H';
                this.ctx.fillText(label, obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height + 12);
                this.ctx.textAlign = 'left';
                
                if (obstacle.type === 'gangster') {
                    this.ctx.strokeStyle = '#9b59b6';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(obstacle.x - 1, obstacle.y - 1, obstacle.width + 2, obstacle.height + 2);
                }
            }
            
            this.ctx.restore();
        });
    }
    
    renderMicrophones() {
        this.microphones.forEach(mic => {
            const bobY = mic.y + Math.sin(mic.bobOffset) * 8;
            
            this.ctx.save();
            this.ctx.globalAlpha = mic.glow * 0.9;
            this.ctx.fillStyle = '#f1c40f';
            this.ctx.beginPath();
            this.ctx.arc(mic.x + mic.width / 2, bobY + mic.height / 2, 25, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
            
            this.ctx.fillStyle = '#2c3e50';
            this.ctx.fillRect(mic.x, bobY, mic.width, mic.height);
            
            this.ctx.fillStyle = '#95a5a6';
            this.ctx.beginPath();
            this.ctx.arc(mic.x + mic.width / 2, bobY + 5, 8, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.fillStyle = '#ecf0f1';
            this.ctx.beginPath();
            this.ctx.arc(mic.x + mic.width / 2 - 2, bobY + 3, 3, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }
    
    renderParticles() {
        this.particles.forEach(particle => {
            const alpha = particle.life / particle.maxLife;
            this.ctx.save();
            this.ctx.globalAlpha = alpha;
            this.ctx.fillStyle = particle.color;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        });
    }
    
    renderUI() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(10, 10, this.canvas.width - 20, 100);
        this.ctx.strokeStyle = '#e74c3c';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(10, 10, this.canvas.width - 20, 100);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.font = 'bold 18px Arial';
        this.ctx.fillText(`Score: ${this.score}`, 20, 35);
        
        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        this.ctx.fillText(`Time: ${timeStr}`, 20, 55);
        
        const character = this.characters[this.currentCharacter];
        this.ctx.fillStyle = character.color;
        this.ctx.fillText(`Character: ${character.name}`, 200, 35);
        
        const healthBarX = 200;
        const healthBarY = 45;
        const healthBarWidth = 120;
        const healthBarHeight = 12;
        
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        
        const healthPercent = character.currentHealth / character.maxHealth;
        const healthColor = healthPercent > 0.6 ? '#27ae60' : 
                           healthPercent > 0.3 ? '#f39c12' : '#e74c3c';
        
        this.ctx.fillStyle = healthColor;
        this.ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight);
        
        this.ctx.strokeStyle = '#ecf0f1';
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        
        const superMeterX = 350;
        const superMeterY = 35;
        const superMeterWidth = 100;
        const superMeterHeight = 12;
        
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.fillRect(superMeterX, superMeterY, superMeterWidth, superMeterHeight);
        
        const superPercent = character.superMeter / character.maxSuperMeter;
        this.ctx.fillStyle = superPercent >= 1 ? '#27ae60' : character.color;
        this.ctx.fillRect(superMeterX, superMeterY, superMeterWidth * superPercent, superMeterHeight);
        
        this.ctx.strokeStyle = '#ecf0f1';
        this.ctx.strokeRect(superMeterX, superMeterY, superMeterWidth, superMeterHeight);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.font = '14px Arial';
        this.ctx.fillText('Super:', superMeterX, superMeterY - 5);
        
        let statusX = 500;
        this.ctx.font = '14px Arial';
        Object.keys(this.characters).forEach(name => {
            const char = this.characters[name];
            this.ctx.fillStyle = char.isAlive ? char.color : '#7f8c8d';
            const marker = name === this.currentCharacter ? 'â—' : 'â—‹';
            this.ctx.fillText(`${marker} ${char.name}`, statusX, 35);
            
            if (char.isAlive) {
                const miniBarWidth = 40;
                const miniBarHeight = 4;
                const miniBarY = 40;
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.fillRect(statusX, miniBarY, miniBarWidth, miniBarHeight);
                
                const miniHealthPercent = char.currentHealth / char.maxHealth;
                this.ctx.fillStyle = char.color;
                this.ctx.fillRect(statusX, miniBarY, miniBarWidth * miniHealthPercent, miniBarHeight);
            }
            
            statusX += 90;
        });
        
        this.ctx.fillStyle = '#f39c12';
        this.ctx.font = '16px Arial';
        this.ctx.fillText(`Speed: ${this.gameSpeed.toFixed(1)}x`, 20, 80);
        
        this.ctx.fillStyle = '#f1c40f';
        this.ctx.fillText(`High: ${this.highScore}`, 200, 80);
    }
    
    renderTouchControls() {
        const buttonSize = 60;
        const margin = 20;
        
        this.drawTouchButton(margin, this.canvas.height - buttonSize - margin, buttonSize, 'â†', this.touchControls.left);
        this.drawTouchButton(margin + buttonSize + 10, this.canvas.height - buttonSize - margin, buttonSize, 'â†’', this.touchControls.right);
        
        this.drawTouchButton(this.canvas.width / 2 - buttonSize / 2, this.canvas.height - buttonSize - margin, buttonSize, 'JUMP', this.touchControls.jump);
        
        this.drawTouchButton(this.canvas.width - buttonSize * 2 - margin - 10, this.canvas.height - buttonSize - margin, buttonSize, 'SWITCH', this.touchControls.switch);
        this.drawTouchButton(this.canvas.width - buttonSize - margin, this.canvas.height - buttonSize - margin, buttonSize, 'SUPER', this.touchControls.super);
    }
    
    drawTouchButton(x, y, size, text, pressed) {
        this.ctx.save();
        
        this.ctx.fillStyle = pressed ? 'rgba(231, 76, 60, 0.9)' : 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(x, y, size, size);
        
        this.ctx.strokeStyle = '#e74c3c';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(x, y, size, size);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.font = `bold ${size / 5}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.fillText(text, x + size / 2, y + size / 2 + size / 10);
        
        this.ctx.restore();
        this.ctx.textAlign = 'left';
    }
    
    renderPauseOverlay() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.font = 'bold 48px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
        
        this.ctx.font = '20px Arial';
        this.ctx.fillText('Press P to resume', this.canvas.width / 2, this.canvas.height / 2 + 50);
        
        this.ctx.textAlign = 'left';
    }
    
    renderGameOverScreen() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.fillStyle = '#e74c3c';
        this.ctx.font = 'bold 48px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 50);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.font = '24px Arial';
        this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 20);
        
        if (this.score >= this.highScore) {
            this.ctx.fillStyle = '#f1c40f';
            this.ctx.fillText('NEW HIGH SCORE!', this.canvas.width / 2, this.canvas.height / 2 + 50);
        }
        
        this.ctx.fillStyle = '#27ae60';
        this.ctx.font = '20px Arial';
        this.ctx.fillText('CLICK TO RESTART', this.canvas.width / 2, this.canvas.height / 2 + 100);
        
        this.ctx.textAlign = 'left';
    }
    
    renderVictoryScreen() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.save();
        this.ctx.shadowColor = '#f1c40f';
        this.ctx.shadowBlur = 20;
        this.ctx.fillStyle = '#f1c40f';
        this.ctx.font = 'bold 48px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('VICTORY!', this.canvas.width / 2, this.canvas.height / 2 - 80);
        this.ctx.restore();
        
        this.ctx.fillStyle = '#27ae60';
        this.ctx.font = '24px Arial';
        this.ctx.fillText('You survived Brooklyn!', this.canvas.width / 2, this.canvas.height / 2 - 30);
        this.ctx.fillText('Song fragment collected!', this.canvas.width / 2, this.canvas.height / 2);
        
        this.ctx.fillStyle = '#ecf0f1';
        this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 40);
        
        if (this.score >= this.highScore) {
            this.ctx.fillStyle = '#f1c40f';
            this.ctx.fillText('NEW HIGH SCORE!', this.canvas.width / 2, this.canvas.height / 2 + 70);
        }
        
        this.ctx.fillStyle = '#27ae60';
        this.ctx.font = '20px Arial';
        this.ctx.fillText('CLICK TO PLAY AGAIN', this.canvas.width / 2, this.canvas.height / 2 + 120);
        
        this.ctx.textAlign = 'left';
    }
    
    startGame() {
        this.gameState = 'playing';
        this.resetGame();
        document.getElementById('playButton').style.display = 'none';
    }
    
    resetGame() {
        this.score = 0;
        this.gameTime = this.config.game.duration;
        this.gameSpeed = 1;
        this.frameCount = 0;
        
        Object.values(this.characters).forEach(char => {
            char.currentHealth = char.maxHealth;
            char.superMeter = 0;
            char.isAlive = true;
        });
        
        this.currentCharacter = 'tireek';
        this.availableCharacters = ['tireek', 'tryston'];
        
        this.player.x = 100;
        this.player.y = this.canvas.height - 120;
        this.player.velocityY = 0;
        this.player.onGround = true;
        this.player.isInvulnerable = false;
        this.player.invulnerabilityTime = 0;
        
        this.obstacles = [];
        this.microphones = [];
        this.particles = [];
        
        this.gameState = 'playing';
    }
    
    loadHighScore() {
        return parseInt(localStorage.getItem('firstOffHighScore') || '0');
    }
    
    saveHighScore() {
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('firstOffHighScore', this.highScore.toString());
        }
    }
    
    startGameLoop() {
        const gameLoop = (currentTime) => {
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            
            this.updatePlayer();
            this.updateObstacles();
            this.updateMicrophones();
            this.updateParticles();
            this.updateGameLogic();
            
            this.render();
            
            requestAnimationFrame(gameLoop);
        };
        
        requestAnimationFrame(gameLoop);
    }
}

// Global functions for UI controls
function startGame() {
    if (window.game) {
        if (window.game.gameState === 'gameOver' || window.game.gameState === 'victory') {
            window.game.resetGame();
        } else {
            window.game.startGame();
        }
    }
}

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {
            alert('Fullscreen not supported on this device');
        });
    } else {
        document.exitFullscreen();
    }
}

// Initialize game when page loads
window.addEventListener('load', () => {
    const game = new FirstOffGame();
    window.game = game;
    
    // Show play button after loading
    setTimeout(() => {
        if (game.gameState === 'menu') {
            document.getElementById('playButton').style.display = 'block';
        }
    }, 2500);
    
    // Handle clicks for game over/victory screens
    document.addEventListener('click', (e) => {
        if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'CANVAS') return;
        
        if (game.gameState === 'gameOver' || game.gameState === 'victory') {
            startGame();
        }
    });
});

// Prevent zoom and improve mobile experience
document.addEventListener('touchstart', function(e) {
    if (e.touches.length > 1) {
        e.preventDefault();
    }
}, { passive: false });

let lastTouchEnd = 0;
document.addEventListener('touchend', function(e) {
    const now = (new Date()).getTime();
    if (now - lastTouchEnd <= 300) {
        e.preventDefault();
    }
    lastTouchEnd = now;
}, false);
    </script>
</body>
</html>